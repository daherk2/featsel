// NystromSpecCMI.cpp automatically generated by bin/add_new_algorithm.pl
// in Wed Feb  7 12:10:39 2018.

//
// NystromSpecCMI.cpp -- implementation of the class "NystromSpecCMI".
//
//    This file is part of the featsel program
//    Copyright (C) 2016  Marcelo S. Reis
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see <http://www.gnu.org/licenses/>.
//

#include "NystromSpecCMI.h"
#include <oct.h>
#include <builtin-defun-decls.h>

NystromSpecCMI::NystromSpecCMI ()
{
  list_of_visited_subsets = new Collection ();
  cost_function = NULL;
  nystrom_sampling_rate = NYSTROM_SAMPLING_RATE;
  A = B = NULL;
  cmi = NULL;
  k = 10; // Starting value at Xuan Vinh et al. (2014).
  p = 0;
}


NystromSpecCMI::NystromSpecCMI (unsigned int number_of_features)
{
  list_of_visited_subsets = new Collection ();
  cost_function = NULL;
  nystrom_sampling_rate = NYSTROM_SAMPLING_RATE;
  A = B = NULL;
  cmi = NULL;
  k = number_of_features;
  p = 0;
}


NystromSpecCMI::NystromSpecCMI (unsigned int number_of_features, double gamma)
{
  list_of_visited_subsets = new Collection ();
  cost_function = NULL;
  nystrom_sampling_rate = gamma;
  A = B = NULL;
  cmi = NULL;
  k = number_of_features;
  p = 0;
}


NystromSpecCMI::NystromSpecCMI (double gamma)
{
  list_of_visited_subsets = new Collection ();
  cost_function = NULL;
  nystrom_sampling_rate = gamma;
  A = B = NULL;
  cmi = NULL;
  k = 10;
  p = 0;
}


NystromSpecCMI::~NystromSpecCMI ()
{
  if (A != NULL && B != NULL)
    for (unsigned int i = 0; i < p; i++)
    {
      delete[] A[i];
      delete[] B[i];
    }

  delete list_of_visited_subsets;
  delete cmi;
  delete[] A;
  delete[] B;
}


void NystromSpecCMI::create_A ()
{
  A = new double *[p];
  for (unsigned int i = 0; i < p; i++)
    A[i] = new double[p];
}


void NystromSpecCMI::create_B ()
{
  unsigned int n = set->get_set_cardinality ();
  B = new double *[p];
  for (unsigned int i = 0; i < p; i++)
    B[i] = new double[n - p];
}


void NystromSpecCMI::sample_Q ()
{
  unsigned int set_card = set->get_set_cardinality ();
  unsigned int n;
  n = set_card;
  p = n * nystrom_sampling_rate;

  create_A ();
  create_B ();

  for (unsigned int i = 0; i < p; i++)
    for (unsigned int j = 0; j < n; j++)
      if (j < p)
        A[i][j] = compute_Q_entry (i, j);
      else
        B[i][j - p] = compute_Q_entry (i, j);
}


double NystromSpecCMI::compute_Q_entry (unsigned int i, unsigned int j)
{
  double value;
  ElementSubset X ("subset", set);

  if (cmi == NULL)
    cmi = new ConditionalMutualInformation (set);

  X.add_element (i);
  X.add_element (j);
  value = cmi->cost (&X);
  return value;
}


double * NystromSpecCMI::rank_features ()
{
  int n = set->get_set_cardinality ();
  double * rank, lambda;

  rank = new double[n];
  for (int i = 0; i < n; i++)
    rank[i] = 0;

  if (p < 1 || set->get_element (0)->get_number_of_values () < 2)
    return rank;

  Matrix A_oct = Matrix (p, p);
  Matrix B_oct = Matrix (p, n - p);
  Matrix B_t   = Matrix (n - p, p);
  ComplexMatrix A_sqrt     = ComplexMatrix (p, p);
  ComplexMatrix A_sqrt_inv = ComplexMatrix (p, p);
  ComplexMatrix A_hat      = ComplexMatrix (p, p);
  ComplexMatrix AB_t       = ComplexMatrix (n, p);
  ComplexMatrix D          = ComplexMatrix (p, p);
  ComplexMatrix X          = ComplexMatrix (p, p);
  ComplexMatrix u          = ComplexMatrix (p, 1);
  ComplexMatrix rank_oct   = ComplexMatrix (n, 1);
  ColumnVector x = ColumnVector (n);
  octave_idx_type i, j, dominant_i;
  octave_value_list in;   // Input/output lists to exchange data with
  octave_value_list out;  // Octave native functions.

  for (i = 0; i < (int) p; i++)
    for (j = 0; j < n; j++)
      if (j < (int) p)
        A_oct (i, j) = A[i][j];
      else
      {
        B_oct (i, j - p) = B[i][j - p];
        B_t   (j - p, i) = B[i][j - p];
      }

  for (i = 0; i < n; i++)
    for (j = 0; j < (int) p; j++)
      if (i < (int) p)
        AB_t (i, j) = A[i][j];
      else
        AB_t (i, j) = B_t (i - p, j);

  in (0) = A_oct; 
  out = Fsqrtm (in, 1);
  A_sqrt = out (0).complex_matrix_value ();

  in (0) = A_sqrt;
  out = Finv (in, 1);
  A_sqrt_inv = out (0).complex_matrix_value ();

  A_hat = A_oct + A_sqrt_inv * B_oct * B_t * A_sqrt_inv;

  in (0) = A_hat;
  out = Feig (in, 2);
  X = out (0).complex_matrix_value ();
  D = out (1).complex_matrix_value ();
  lambda = real (D (0, 0));
  
  dominant_i = 0;
  for (i = 1; i < (int) p; i++)
    if (D (i,i).imag () == 0 && D (i,i).real () > lambda)
    {
      lambda = D(i,i).real ();
      dominant_i = i;
    }

  double sigma_sqrt = D (dominant_i, dominant_i).real ();
  sigma_sqrt = sqrt (sigma_sqrt);
  for (i = 0; i < (int) p; i++)
    u (i, 0) = X (i, dominant_i);

  rank_oct = 1 / sigma_sqrt * AB_t * A_sqrt_inv * u;
  for (i = 0; i < n; i++)
    rank[i] = rank_oct (i).real ();
  return rank;
}


void NystromSpecCMI::get_minima_list (unsigned int max_size_of_minima_list)
{
  timeval begin_program, end_program;
  gettimeofday (& begin_program, NULL);

  unsigned int set_card = set->get_set_cardinality ();
  double * feature_score; 
  sample_Q ();
  feature_score = rank_features ();
  multimap<double, unsigned int> sorted_features;
  multimap <double, unsigned int>::reverse_iterator it;

  for (unsigned int i = 0; i < set_card; i++)
  {
    sorted_features.insert (pair<double, unsigned int> (feature_score[i], i));
  }

  ElementSubset X ("", set), * Y;
  unsigned int i = k;
  for (it = sorted_features.rbegin (); it != sorted_features.rend (); it++)
  {
    if (PRINT_FEATURE_RANKING)
      cout << it->second + 1 << " : " << it->first << endl;

    if (PRINT_SUBSET_CHAIN)
    {
      /* It prints into STDOUT the chain [\emptyset, X_k],
         where X_k is the subset with k best-ranked features. */
      Y = new ElementSubset ("", set);
      Y->copy (&X);
      Y->cost = cost_function->cost (Y);   
      list_of_minima.push_back (Y); 
    }

    if (i >= 1)
    {
      X.add_element (it->second); 
      i--;
    }
  }
  Y = new ElementSubset ("", set);
  Y->copy (&X);
  Y->cost = cost_function->cost (Y);   
  list_of_minima.push_back (Y); 

  delete[] feature_score;
  number_of_visited_subsets =
    cost_function->get_number_of_calls_of_cost_function ();
  clean_list_of_minima (max_size_of_minima_list);

  gettimeofday (& end_program, NULL);
  elapsed_time_of_the_algorithm = diff_us (end_program, begin_program);
}


double NystromSpecCMI::get_Q_sample (unsigned int i, unsigned int j)
{
  if (A == NULL || B == NULL)
    sample_Q ();

  unsigned int p;
  unsigned int set_card =  set->get_set_cardinality ();
  p = set_card * nystrom_sampling_rate;
  
  if (j > set_card || i > p)
    return -1;

  if (j < p)
    return A[i][j];
  else
    return B[i][j - p];
}